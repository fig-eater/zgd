const std = @import("std");

const Build = std.Build;
const Step = Build.Step;
const Target = Build.ResolvedTarget;
const OptimizeMode = std.builtin.OptimizeMode;

pub const zigodot_module_name = "godot";
const zigodot_module_root = "src/gen/godot.zig";

pub fn createGeneratorExeArtifact(
    b: *Build,
    target: Target,
    optimize: OptimizeMode,
) *Step.InstallArtifact {

    // generator executable compile step
    const generator_exe = b.addExecutable(.{
        .name = "zigodot_generator",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });
    const generator_exe_artifact = b.addInstallArtifact(generator_exe, .{});
    return generator_exe_artifact;
}

pub fn buildRunGeneratorStep(b: *Build, generator_exe_artifact: *Step.InstallArtifact) *Step {
    const run_generator_step = b.step("run", "Run the generator");

    // User runs generator from zig build run
    const run_cmd = b.addRunArtifact(generator_exe_artifact.artifact);
    run_cmd.step.dependOn(&generator_exe_artifact.step);

    // This allows the user to pass arguments to the application in the build
    // command itself, like this: `zig build run -- arg1 arg2 etc`
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    run_generator_step.dependOn(&run_cmd.step);

    return run_generator_step;
}

pub fn buildBindingsStep(b: *Build, generator_exe_artifact: *Step.InstallArtifact, dump_api_step: *Step) *Step {
    const bindings_step = b.step("bindings", "Build godot bindings");
    bindings_step.dependOn(dump_api_step);
    bindings_step.dependOn(&generator_exe_artifact.step);

    // Command for building the bindings to the gen folder
    const build_bindings_cmd = b.addRunArtifact(generator_exe_artifact.artifact);
    build_bindings_cmd.addArgs(&.{ b.dupePath("src/api/extension_api.json"), b.dupePath("src/gen/") });
    bindings_step.dependOn(&build_bindings_cmd.step);

    return bindings_step;
}

pub fn addModule(
    b: *Build,
    build_bindings_step: *Step,
    target: Target,
    optimize: OptimizeMode,
) *Build.Module {
    // define root file of zigodot generated by bindings step
    // this being a generated file will make it so when the zigodot_module is requested
    // it will run the bindings_step to generate the root file
    const generated_file = b.allocator.create(Build.GeneratedFile) catch @panic("OOM");
    generated_file.* = .{
        .step = build_bindings_step,
        .path = b.dupePath(zigodot_module_root),
    };

    const overloading_dependency = b.dependency("overloading", .{
        .target = target,
        .optimize = optimize,
    });

    const module = b.addModule(zigodot_module_name, .{
        .root_source_file = .{ .generated = .{ .file = generated_file } },
        .imports = &.{
            .{ .name = "overloading", .module = overloading_dependency.module("overloading") },
        },
    });

    return module;
}

pub fn buildExampleExtensionStep(
    b: *Build,
    target: Target,
    optimize: OptimizeMode,
) *Step {
    const example_extension_step = b.step("example", "Build zigodot example");

    const example_extension_lib = b.addSharedLibrary(.{
        .name = "zigodot_example",
        .root_source_file = b.path("src/example/example_extension.zig"),
        .target = target,
        .optimize = optimize,
    });

    example_extension_lib.root_module.addImport(zigodot_module_name, b.modules.get(zigodot_module_name).?);

    const example_extension_install_artifact = b.addInstallArtifact(example_extension_lib, .{});

    example_extension_step.dependOn(&example_extension_install_artifact.step);
    return example_extension_step;
}

pub fn runExampleStep(b: *Build, target: Target, optimize: OptimizeMode) *Step {
    const run_example_step = b.step("run-example", "Run zigodot example");
    const example_exe = b.addExecutable(.{
        .name = "zgd_example",
        .root_source_file = b.path("src/example/example_extension.zig"),
        .target = target,
        .optimize = optimize,
    });
    // place the exe in the install directory
    const example_exe_install_artifact = b.addInstallArtifact(example_exe, .{});
    example_exe.root_module.addImport(zigodot_module_name, b.modules.get(zigodot_module_name).?);
    // run the exe
    const run_artifact = b.addRunArtifact(example_exe_install_artifact.artifact);

    run_example_step.dependOn(&example_exe_install_artifact.step);
    run_example_step.dependOn(&run_artifact.step);
    return run_example_step;
}

pub fn dumpApiStep(b: *std.Build) *Step {
    const dump_api_step = b.step("dump-api", "Dump godot api");
    b.build_root.handle.makeDir("src/api") catch |err| if (err != error.PathAlreadyExists)
        @panic("failed to create api path");
    const cmd = b.addSystemCommand(&.{ "godot", "--headless", "--dump-extension-api" });
    cmd.cwd = b.path("src/api");
    const cmd2 = b.addSystemCommand(&.{ "godot", "--headless", "--dump-gdextension-interface" });
    cmd2.cwd = b.path("src/api");
    dump_api_step.dependOn(&cmd.step);
    dump_api_step.dependOn(&cmd2.step);
    return dump_api_step;
}

pub fn build(b: *std.Build) void {
    // Config
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const generator_exe_artifact = createGeneratorExeArtifact(b, target, optimize);
    _ = buildRunGeneratorStep(b, generator_exe_artifact);
    const dump_api_step = dumpApiStep(b);
    const bindings_step = buildBindingsStep(b, generator_exe_artifact, dump_api_step);
    _ = addModule(b, bindings_step, target, optimize);
    _ = buildExampleExtensionStep(b, target, optimize);
    _ = runExampleStep(b, target, optimize);
}
