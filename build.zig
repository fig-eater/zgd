const std = @import("std");
const builtin = @import("builtin");

const Build = std.Build;
const Step = Build.Step;
const Target = Build.ResolvedTarget;
const OptimizeMode = std.builtin.OptimizeMode;

pub const zigodot_module_name = "godot";

const bindings_dir = "src/bindings/";

const zigodot_module_root = bindings_dir ++ "godot.zig";
const bindings_header = bindings_dir ++ "header.zig";
const generator_root = "src/generator/root.zig";
const example_root = "src/example/example_extension.zig";

pub fn createGeneratorExeArtifact(
    b: *Build,
    target: Target,
    optimize: OptimizeMode,
) *Step.InstallArtifact {
    // generator executable compile step
    const generator_exe = b.addExecutable(.{
        .name = "zigodot_generator",
        .root_source_file = b.path(generator_root),
        .target = target,
        .optimize = optimize,
    });
    const generator_exe_artifact = b.addInstallArtifact(generator_exe, .{});
    return generator_exe_artifact;
}

pub fn buildRunGeneratorStep(b: *Build, generator_exe_artifact: *Step.InstallArtifact) *Step {
    const run_generator_step = b.step("run", "Run the generator");

    // User runs generator from zig build run
    const run_cmd = b.addRunArtifact(generator_exe_artifact.artifact);
    run_cmd.step.dependOn(&generator_exe_artifact.step);

    // This allows the user to pass arguments to the application in the build
    // command itself, like this: `zig build run -- arg1 arg2 etc`
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    run_generator_step.dependOn(&run_cmd.step);

    return run_generator_step;
}

pub fn buildBindingsStep(
    b: *Build,
    generator_exe_artifact: *Step.InstallArtifact,
) *Step {
    const bindings_step = b.step("bindings", "Build godot bindings");
    const force = b.option(bool, "regen-zigodot", "Force regeneration of godot bindings");
    if ((force != null and force.?) or !areBindingsUpToDate(b)) {
        bindings_step.dependOn(&generator_exe_artifact.step);

        // Command for building the bindings to the gen folder
        const build_bindings_cmd = b.addRunArtifact(generator_exe_artifact.artifact);
        build_bindings_cmd.addArgs(&.{b.dupePath(bindings_dir)});
        bindings_step.dependOn(&build_bindings_cmd.step);
    }

    return bindings_step;
}

pub fn addModule(
    b: *Build,
    build_bindings_step: *Step,
    target: Target,
    optimize: OptimizeMode,
) *Build.Module {
    // define root file of zigodot generated by bindings step
    // this being a generated file will make it so when the zigodot_module is requested
    // it will run the bindings_step to generate the root file
    const generated_file = b.allocator.create(Build.GeneratedFile) catch @panic("OOM");
    generated_file.* = .{
        .step = build_bindings_step,
        .path = b.dupePath(zigodot_module_root),
    };

    const overloading_dependency = b.dependency("overloading", .{
        .target = target,
        .optimize = optimize,
    });

    const module = b.addModule(zigodot_module_name, .{
        .root_source_file = .{ .generated = .{ .file = generated_file } },
        .imports = &.{
            .{ .name = "overloading", .module = overloading_dependency.module("overloading") },
        },
    });

    return module;
}

pub fn buildExampleExtensionStep(
    b: *Build,
    target: Target,
    optimize: OptimizeMode,
) *Step {
    const example_extension_step = b.step("example", "Build zigodot example");

    const example_extension_lib = b.addSharedLibrary(.{
        .name = "zigodot_example",
        .root_source_file = b.path(example_root),
        .target = target,
        .optimize = optimize,
    });

    example_extension_lib.root_module.addImport(
        zigodot_module_name,
        b.modules.get(zigodot_module_name).?,
    );

    const example_extension_install_artifact = b.addInstallArtifact(example_extension_lib, .{});

    example_extension_step.dependOn(&example_extension_install_artifact.step);
    return example_extension_step;
}

pub fn runExampleStep(b: *Build, target: Target, optimize: OptimizeMode) *Step {
    const run_example_step = b.step("run-example", "Run zigodot example");
    const example_exe = b.addExecutable(.{
        .name = "zgd_example",
        .root_source_file = b.path(example_root),
        .target = target,
        .optimize = optimize,
    });
    // place the exe in the install directory
    const example_exe_install_artifact = b.addInstallArtifact(example_exe, .{});
    example_exe.root_module.addImport(zigodot_module_name, b.modules.get(zigodot_module_name).?);
    // run the exe
    const run_artifact = b.addRunArtifact(example_exe_install_artifact.artifact);

    run_example_step.dependOn(&example_exe_install_artifact.step);
    run_example_step.dependOn(&run_artifact.step);
    return run_example_step;
}

pub fn areBindingsUpToDate(b: *Build) bool {
    const version_file = b.build_root.handle.openFile("src/bindings/version", .{}) catch
        return false;
    defer version_file.close();

    const godot_version_cached = version_file.reader().readUntilDelimiterAlloc(
        b.allocator,
        '\n',
        1024,
    ) catch return false;
    defer b.allocator.free(godot_version_cached);

    const zig_version_cached = version_file.reader().readUntilDelimiterAlloc(
        b.allocator,
        '\n',
        1024,
    ) catch return false;
    defer b.allocator.free(zig_version_cached);

    const result = std.process.Child.run(.{
        .allocator = b.allocator,
        .argv = &.{ "godot", "--version" },
    }) catch return false;
    defer {
        b.allocator.free(result.stderr);
        b.allocator.free(result.stdout);
    }
    var seq = std.mem.splitSequence(u8, result.stdout, "\n");
    return (std.mem.eql(u8, godot_version_cached, seq.first()) and
        std.mem.eql(u8, zig_version_cached, builtin.zig_version_string));
}

pub fn build(b: *std.Build) !void {
    // Config
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const generator_exe_artifact = createGeneratorExeArtifact(b, target, optimize);
    _ = buildRunGeneratorStep(b, generator_exe_artifact);
    const bindings_step = buildBindingsStep(b, generator_exe_artifact);
    _ = addModule(b, bindings_step, target, optimize);
    _ = buildExampleExtensionStep(b, target, optimize);
    _ = runExampleStep(b, target, optimize);
}
