const std = @import("std");
const builtin = @import("builtin");
const steps = struct {
    const dump_api = @import("build-steps/dump_api.zig");
    const generate_bindings = @import("build-steps/generate_bindings.zig");
};

const Build = std.Build;
const Step = Build.Step;
const ResolvedTarget = Build.ResolvedTarget;
const OptimizeMode = std.builtin.OptimizeMode;

const BuildConfig = @import("common.zig").BuildConfig;

const Precision = enum { single, double };

const zgd_precision_default = Precision.single;

const bindings_dir = "src/bindings/";

const zgd_module_root = bindings_dir ++ "godot.zig";
const generator_root = "src/generator/root.zig";

pub fn build(b: *Build) !void {

    // Config
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const aro_path_option = b.option(
        []const u8,
        "aro-path",
        "Path to arocc root src file. " ++
            "Optional, attempts to find arocc from ZIG_LIB_DIR if not provided",
    );

    const aro_root_path = if (aro_path_option) |p| p else blk: {
        // TODO: get these panics(or errors) to only run when actually trying to build something.
        //       they currently get triggered if `zig build --help` is ran

        const panic_str = "Failed to get ZIG_LIB_DIR environment variable " ++
            "needed for finding the arocc path. " ++
            "Please define it or provide the -Daro-path option when running zig build";
        const lib_dir = std.zig.EnvVar.get(.ZIG_LIB_DIR, b.allocator) catch
            @panic(panic_str) orelse
            @panic(panic_str);

        break :blk b.pathJoin(&.{ lib_dir, "compiler", "aro", "aro.zig" });
    };

    const zgd_godot = b.option(
        []const u8,
        "zgd-godot",
        "Path to godot to use for binding generation. Default uses godot in path",
    );
    const zgd_godot_path: ?Build.LazyPath = if (zgd_godot) |p| b.path(p) else null;

    const zgd_force = b.option(
        bool,
        "zgd-force",
        "Force regeneration of godot bindings. Default: false",
    ) orelse false;

    const zgd_precision = b.option(
        Precision,
        "zgd-precision",
        "Float precision for bindings. Default: " ++ @tagName(zgd_precision_default),
    ) orelse zgd_precision_default;

    const build_config: BuildConfig = switch (target.result.ptrBitWidth()) {
        32 => switch (zgd_precision) {
            .single => .float_32,
            .double => .double_32,
        },
        64 => switch (zgd_precision) {
            .single => .float_64,
            .double => .double_64,
        },
        else => @panic("Target is not supported, must have bit width of 32 or 64"),
    };

    const aro_module = localAroModule(b, Build.LazyPath{ .cwd_relative = aro_root_path });
    const dump_api_result = steps.dump_api.step(b, target, zgd_godot_path);
    const generate_bindings_step = steps.generate_bindings.step(
        b,
        dump_api_result.step,
        dump_api_result.api_file,
        build_config,
        zgd_force,
        b.path(bindings_dir),
        target,
        optimize,
        aro_module,
        dump_api_result.gdextension_interface_module,
    );
    _ = addModule(
        b,
        generate_bindings_step,
        dump_api_result.gdextension_interface_module,
        target,
        optimize,
    );
    b.default_step = generate_bindings_step;
}

fn localAroModule(b: *Build, aro_root: Build.LazyPath) *Build.Module {
    return b.createModule(.{
        .root_source_file = aro_root,
    });
}

pub fn addModule(
    b: *Build,
    build_bindings_step: *Step,
    interface_module: *Build.Module,
    target: ResolvedTarget,
    optimize: OptimizeMode,
) *Build.Module {
    // define root file of zgd generated by bindings step
    // this being a generated file will make it so when the `godot` module is requested
    // it will run the bindings_step to generate the root file
    const generated_file = b.allocator.create(Build.GeneratedFile) catch @panic("OOM");
    generated_file.* = .{
        .step = build_bindings_step,
        .path = b.dupePath(zgd_module_root),
    };

    const overloading_dependency = b.dependency("overloading", .{
        .target = target,
        .optimize = optimize,
    });

    const module = b.addModule("godot", .{
        .root_source_file = .{ .generated = .{ .file = generated_file } },
        .imports = &.{
            .{ .name = "overloading", .module = overloading_dependency.module("overloading") },
            .{ .name = "gdextension_interface", .module = interface_module },
        },
    });

    return module;
}

// pub fn areBindingsUpToDate(b: *Build, godot_path: []const u8) bool {
//     const version_file = b.build_root.handle.openFile("src/bindings/version", .{}) catch
//         return false;
//     defer version_file.close();

//     const godot_version_cached = version_file.reader().readUntilDelimiterAlloc(
//         b.allocator,
//         '\n',
//         1024,
//     ) catch return false;
//     defer b.allocator.free(godot_version_cached);

//     const zig_version_cached = version_file.reader().readUntilDelimiterAlloc(
//         b.allocator,
//         '\n',
//         1024,
//     ) catch return false;
//     defer b.allocator.free(zig_version_cached);

//     const result = std.process.Child.run(.{
//         .allocator = b.allocator,
//         .argv = &.{ godot_path, "--version" },
//     }) catch return false;
//     defer {
//         b.allocator.free(result.stderr);
//         b.allocator.free(result.stdout);
//     }
//     var seq = std.mem.splitSequence(u8, result.stdout, "\n");
//     return (std.mem.eql(u8, godot_version_cached, seq.first()) and
//         std.mem.eql(u8, zig_version_cached, builtin.zig_version_string));
// }

pub fn runGodot(b: *Build, godot_path: ?Build.LazyPath, args: ?[]const []const u8) *Step.Run {
    const run_godot = Step.Run.create(b, "run godot");
    if (godot_path) |p| {
        run_godot.addFileArg(p);
    } else {
        run_godot.addArg("godot");
    }
    if (args) |a| {
        run_godot.addArgs(a);
    }
    return run_godot;
}
