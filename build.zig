const std = @import("std");
const builtin = @import("builtin");
const GodotRunner = @import("build/GodotRunner.zig");
const Options = @import("build/Options.zig");
const Build = std.Build;
const Step = Build.Step;
const BuildConfig = @import("src/common.zig").BuildConfig;

const gen_dir = "src/";
const gen_root = gen_dir ++ "gen_root.zig";
const generator_root = "src/generator_root.zig";

pub fn build(b: *Build) !void {
    // config
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    // package options
    const opts = Options.init(b);

    // helper
    const godot_runner = GodotRunner{
        .build = b,
        // TODO allow for lazy path to built godot exe
        .godot_path = if (opts.godot_path) |p| b.path(p) else null,
    };

    const aro_module, const aro_include_path = aroModule(b, target, optimize);

    // steps
    _, const generator_exe = buildGenerator(
        b,
        aro_module,
        target,
        optimize,
    );

    const dumped_api = buildDumpApi(b, godot_runner, opts.dump_path);
    const build_bindings = buildBindings(
        b,
        generator_exe,

        // to be passed into generator
        dumped_api.api_file,
        dumped_api.interface_file,
        aro_include_path,
        opts.precision,
        target,

        // options
        opts.force_bindings_regen,
        b.path(gen_dir),
    );

    const overloading_dependency = b.dependency("overloading", .{
        .target = target,
        .optimize = optimize,
    });
    const overloading_module = overloading_dependency.module("overloading");

    // gen module
    const gen_module = genModule(b, build_bindings, "src/gen_root.zig", overloading_module);

    // godot module
    const godot_module = godotModule(b, gen_module, "src/godot_root.zig");

    // this dummy is only for helping zls with the modules
    const dummy = b.addSharedLibrary(.{
        .name = "dummy",
        .target = target,
        .optimize = optimize,
        .root_source_file = b.path("src/dummy.zig"),
    });
    dummy.root_module.addImport("gen", gen_module);
    dummy.root_module.addImport("godot", godot_module);
    dummy.root_module.addImport("overloading", overloading_module);
    b.getInstallStep().dependOn(&dummy.step);
}

fn genModule(
    b: *Build,
    generate_bindings_step: *Step,
    root: []const u8,
    overloading_module: *Build.Module,
) *Build.Module {
    // define root file of zgd generated by bindings step
    // this being a generated file will make it so when the `gen` module is requested
    // it will run the bindings_step to generate the root file
    const generated_file = b.allocator.create(Build.GeneratedFile) catch @panic("OOM");
    generated_file.* = .{
        .step = generate_bindings_step,
        .path = root,
    };

    const module = b.addModule("gen", .{
        .root_source_file = .{ .generated = .{ .file = generated_file } },
        .imports = &.{
            .{ .name = "overloading", .module = overloading_module },
        },
    });

    return module;
}

fn godotModule(
    b: *Build,
    gen_module: *Build.Module,
    root: []const u8,
) *Build.Module {
    const module = b.addModule("godot", .{
        .root_source_file = b.path(root),
        .imports = &.{
            .{ .name = "gen", .module = gen_module },
        },
    });
    return module;
}

fn aroModule(b: *Build, target: Build.ResolvedTarget, optimize: std.builtin.OptimizeMode) struct { *Build.Module, Build.LazyPath } {
    const aro_dep = b.dependency("aro", .{
        .target = target,
        .optimize = optimize,
    });
    const aro_module = aro_dep.module("aro");
    return .{ aro_module, aro_dep.builder.path("include") };
}

fn buildGenerator(
    b: *Build,
    aro_module: *Build.Module,
    target: Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
) struct { *Step, *Step.Compile } {
    const generator_step = b.step(
        "generator",
        "Build and install generator artifact to prefix path",
    );
    const generator_exe = b.addExecutable(.{
        .name = "zgd_generator",
        .root_source_file = b.path(generator_root),
        .target = target,
        .optimize = optimize,
    });
    generator_exe.root_module.addImport("aro", aro_module);

    const install_generator = b.addInstallArtifact(generator_exe, .{});
    generator_step.dependOn(&install_generator.step);
    return .{ generator_step, generator_exe };
}

fn buildDumpApi(
    b: *Build,
    godot_runner: GodotRunner,
    dump_path: ?[]const u8,
) *DumpApi {
    const dump_api_step = b.step("dump-api", "Dump GDExtension api");
    const dump_api = DumpApi.init(b, godot_runner);
    dump_api_step.dependOn(&dump_api.step);
    if (dump_path) |path| {
        dump_api_step.dependOn(&b.addInstallFileWithDir(
            dump_api.api_file,
            .{ .custom = path },
            "extension_api.json",
        ).step);
        dump_api_step.dependOn(&b.addInstallFileWithDir(
            dump_api.interface_file,
            .{ .custom = path },
            "gdextension_interface.h",
        ).step);
    }
    return dump_api;
}

const DumpApi = struct {
    step: Step,
    api_file: Build.LazyPath,
    interface_file: Build.LazyPath,
    pub fn init(b: *Build, godot_runner: GodotRunner) *DumpApi {
        const dump_api = b.allocator.create(DumpApi) catch @panic("OOM");
        dump_api.step = Step.init(.{
            .name = "dump api",
            .id = .custom,
            .owner = b,
        });

        {
            var run_godot = godot_runner.run(&.{ "--headless", "--dump-extension-api" });
            dump_api.api_file = run_godot.addOutputFileArg("extension_api.json");
            run_godot.cwd = dump_api.api_file.dirname();
            dump_api.api_file.addStepDependencies(&dump_api.step);
        }

        {
            var run_godot = godot_runner.run(&.{ "--headless", "--dump-gdextension-interface" });
            dump_api.interface_file = run_godot.addOutputFileArg("gdextension_interface.h");
            run_godot.cwd = dump_api.interface_file.dirname();
            dump_api.interface_file.addStepDependencies(&dump_api.step);
        }

        return dump_api;
    }
};

fn buildBindings(
    b: *Build,
    generator_exe: *Step.Compile,

    // to be passed into generator
    api_file: Build.LazyPath,
    interface_file: Build.LazyPath,
    include_path: Build.LazyPath,
    precision: Options.Precision,
    target: Build.ResolvedTarget,

    // options
    force_regen: bool,
    output_dir: Build.LazyPath,
) *Step {
    _ = force_regen; // autofix
    const CheckBuildConfig = struct {
        step: Step,
        build_config: ?BuildConfig,

        fn init(bld: *Build, build_config: ?BuildConfig) *@This() {
            const check_build_config = bld.allocator.create(@This()) catch @panic("OOM");
            check_build_config.* = .{
                .step = Step.init(.{
                    .name = "check build config",
                    .id = .custom,
                    .owner = bld,
                    .makeFn = &makeFn,
                }),
                .build_config = build_config,
            };
            return check_build_config;
        }

        fn makeFn(step: *Step, _: std.Progress.Node) anyerror!void {
            const pre_generate_check: *@This() = @fieldParentPtr("step", step);
            if (pre_generate_check.build_config == null) {
                std.log.err("Target is not supported, target must have bit width of 32 or 64", .{});
                return error.TargetNotSupported;
            }
        }
    };

    const generate_bindings_step = b.step("bindings", "generate godot bindings");

    // TODO force rebuild if config is different than saved in version

    const build_config: ?BuildConfig = switch (target.result.ptrBitWidth()) {
        32 => switch (precision) {
            .single => .float_32,
            .double => .double_32,
        },
        64 => switch (precision) {
            .single => .float_64,
            .double => .double_64,
        },
        else => null,
    };

    const check_build_config = CheckBuildConfig.init(b, build_config);

    const build_bindings_cmd = b.addRunArtifact(generator_exe);
    if (build_config) |bc| build_bindings_cmd.addArg(@tagName(bc));
    build_bindings_cmd.addFileArg(api_file);
    build_bindings_cmd.addFileArg(interface_file);
    build_bindings_cmd.addFileArg(include_path);
    build_bindings_cmd.addFileArg(output_dir);
    build_bindings_cmd.step.dependOn(&check_build_config.step);

    generate_bindings_step.dependOn(&build_bindings_cmd.step);
    return generate_bindings_step;
}
